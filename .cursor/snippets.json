{
    "snippets": {
        "circuit-breaker-check": {
            "prefix": "cbcheck",
            "body": [
                "from src.core.circuit_breaker import gemini_circuit_breaker",
                "",
                "if not gemini_circuit_breaker.can_execute():",
                "    logger.warning(\"${1:Operation} skipped - circuit breaker OPEN\")",
                "    return ${2:None}",
                "",
                "try:",
                "    ${3:# Your operation here}",
                "    gemini_circuit_breaker.record_success()",
                "    return ${4:result}",
                "except requests.HTTPError as e:",
                "    gemini_circuit_breaker.record_failure(",
                "        status_code=e.response.status_code",
                "    )",
                "    raise"
            ],
            "description": "Circuit breaker integration pattern"
        },
        "secure-api-call": {
            "prefix": "secapi",
            "body": [
                "def ${1:api_operation}(${2:params}) -> ${3:ReturnType}:",
                "    \"\"\"${4:Description of the API operation}.",
                "    ",
                "    Args:",
                "        ${2:params}: ${5:Parameter description}",
                "        ",
                "    Returns:",
                "        ${3:ReturnType}: ${6:Return description}",
                "        ",
                "    Raises:",
                "        ValidationError: If input data is invalid",
                "        CircuitBreakerError: If circuit breaker is open",
                "    \"\"\"",
                "    # Validate input",
                "    if not ${2:params}:",
                "        raise ValidationError(\"${7:Invalid input}\")",
                "    ",
                "    # Check circuit breaker",
                "    if not gemini_circuit_breaker.can_execute():",
                "        raise CircuitBreakerError(\"${1:api_operation} halted - circuit breaker OPEN\")",
                "    ",
                "    try:",
                "        # Log operation start",
                "        logger.info(f\"Starting ${1:api_operation}\", extra={",
                "            \"operation\": \"${1:api_operation}\",",
                "            \"correlation_id\": generate_correlation_id()",
                "        })",
                "        ",
                "        ${8:# Implementation here}",
                "        ",
                "        gemini_circuit_breaker.record_success()",
                "        return ${9:result}",
                "        ",
                "    except requests.HTTPError as e:",
                "        gemini_circuit_breaker.record_failure(",
                "            status_code=e.response.status_code",
                "        )",
                "        logger.error(f\"${1:api_operation} failed: {e}\", extra={",
                "            \"status_code\": e.response.status_code,",
                "            \"response_text\": e.response.text[:200]",
                "        })",
                "        raise",
                "    except Exception as e:",
                "        gemini_circuit_breaker.record_failure()",
                "        logger.exception(f\"Unexpected error in ${1:api_operation}\")",
                "        raise"
            ],
            "description": "Secure API call with circuit breaker and comprehensive error handling"
        },
        "test-with-mocks": {
            "prefix": "testmock",
            "body": [
                "@pytest.fixture",
                "def mock_${1:service}_client():",
                "    with patch('src.clients.${1:service}_client.${2:ClientClass}') as mock:",
                "        mock.get_instance.return_value.${3:method}.return_value = ${4:mock_response}",
                "        yield mock",
                "",
                "@pytest.fixture",
                "def mock_circuit_breaker():",
                "    with patch('src.core.circuit_breaker.gemini_circuit_breaker') as mock:",
                "        mock.can_execute.return_value = True",
                "        mock.is_open.return_value = False",
                "        yield mock",
                "",
                "def test_${5:function_name}(mock_${1:service}_client, mock_circuit_breaker):",
                "    \"\"\"Test ${5:function_name} with proper mocking.\"\"\"",
                "    # Arrange",
                "    ${6:# Setup test data}",
                "    ",
                "    # Act",
                "    result = ${5:function_name}(${7:test_params})",
                "    ",
                "    # Assert",
                "    assert ${8:expected_condition}",
                "    mock_${1:service}_client.get_instance.assert_called_once()",
                "    mock_circuit_breaker.record_success.assert_called_once()"
            ],
            "description": "Test template with comprehensive mocking"
        },
        "error-handler": {
            "prefix": "errhandle",
            "body": [
                "try:",
                "    ${1:# Operation here}",
                "except ValidationError as e:",
                "    logger.error(f\"Validation failed: {e}\", extra={",
                "        \"operation\": \"${2:operation_name}\",",
                "        \"error_type\": \"validation\",",
                "        \"correlation_id\": ${3:correlation_id}",
                "    })",
                "    raise",
                "except CircuitBreakerError as e:",
                "    logger.warning(f\"Circuit breaker prevented operation: {e}\", extra={",
                "        \"operation\": \"${2:operation_name}\",",
                "        \"circuit_state\": gemini_circuit_breaker.state.value",
                "    })",
                "    return ${4:fallback_result}",
                "except requests.HTTPError as e:",
                "    logger.error(f\"API request failed: {e}\", extra={",
                "        \"operation\": \"${2:operation_name}\",",
                "        \"status_code\": e.response.status_code,",
                "        \"response_text\": e.response.text[:200]",
                "    })",
                "    raise",
                "except Exception as e:",
                "    logger.exception(f\"Unexpected error in ${2:operation_name}\")",
                "    raise ${5:CustomError}(f\"${2:operation_name} failed\") from e"
            ],
            "description": "Comprehensive error handling pattern"
        },
        "agent-call": {
            "prefix": "agent",
            "body": [
                "def ${1:generate_content}(${2:input_data}: Dict[str, Any]) -> Optional[Dict[str, Any]]:",
                "    \"\"\"Generate content using AI agent with circuit breaker protection.",
                "    ",
                "    Args:",
                "        ${2:input_data}: Input data for content generation",
                "        ",
                "    Returns:",
                "        Generated content or None if circuit breaker is open",
                "    \"\"\"",
                "    # Check circuit breaker before expensive AI operation",
                "    if not gemini_circuit_breaker.can_execute():",
                "        logger.warning(\"${1:generate_content} skipped - circuit breaker OPEN\")",
                "        return None",
                "    ",
                "    # Check cost limits",
                "    if daily_ai_cost() > config.MAX_DAILY_AI_COST:",
                "        logger.warning(\"${1:generate_content} skipped - daily cost limit reached\")",
                "        return None",
                "    ",
                "    try:",
                "        agent_manager = get_agent_manager()",
                "        result = agent_manager.${3:generate_marketing_fields}(${2:input_data})",
                "        ",
                "        # Log AI usage for cost tracking",
                "        if result and 'tokens_used' in result:",
                "            logger.info(f\"AI operation completed\", extra={",
                "                \"operation\": \"${1:generate_content}\",",
                "                \"tokens_used\": result['tokens_used'],",
                "                \"estimated_cost\": result.get('estimated_cost', 0)",
                "            })",
                "        ",
                "        return result",
                "        ",
                "    except Exception as e:",
                "        logger.error(f\"${1:generate_content} failed: {e}\")",
                "        return None"
            ],
            "description": "AI agent call with circuit breaker and cost tracking"
        },
        "config-validation": {
            "prefix": "configval",
            "body": [
                "def validate_${1:component}_config() -> bool:",
                "    \"\"\"Validate ${1:component} configuration.",
                "    ",
                "    Returns:",
                "        True if configuration is valid",
                "        ",
                "    Raises:",
                "        ConfigurationError: If required config is missing",
                "    \"\"\"",
                "    required_vars = {",
                "        '${2:CONFIG_VAR}': config.${2:CONFIG_VAR},",
                "        '${3:ANOTHER_VAR}': config.${3:ANOTHER_VAR}",
                "    }",
                "    ",
                "    missing_vars = [var for var, value in required_vars.items() if not value]",
                "    if missing_vars:",
                "        raise ConfigurationError(f\"Required config missing: {missing_vars}\")",
                "    ",
                "    logger.info(f\"${1:component} configuration validated successfully\")",
                "    return True"
            ],
            "description": "Configuration validation pattern"
        }
    },
    "fileTemplates": {
        "agent": {
            "extension": ".py",
            "template": "src/templates/agent_template.py",
            "description": "AI agent template with circuit breaker integration"
        },
        "client": {
            "extension": ".py",
            "template": "src/templates/client_template.py",
            "description": "API client template with fault tolerance"
        },
        "service": {
            "extension": ".py",
            "template": "src/templates/service_template.py",
            "description": "Service layer template with dependency injection"
        },
        "test": {
            "extension": ".py",
            "template": "tests/templates/test_template.py",
            "description": "Test template with comprehensive mocking"
        }
    }
}
